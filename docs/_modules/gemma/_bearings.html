

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>gemma._bearings &mdash; gemma 1.2.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> gemma
          

          
          </a>

          
            
            
              <div class="version">
                1.2.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../basic_usage.html">Basic Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example_objects.html">Example Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bearings.html">Bearings: Access Data Generically</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../courses.html">Courses: Data as Paths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../compasses.html">Compasses: Describe Objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../surveyors.html">Surveyors: Traverse Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cartographers.html">Cartographers: Move Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../exceptions.html">Exceptions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../extension_xml.html">Extension: XML</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../extending.html">Extending gemma</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">gemma</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>gemma._bearings</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for gemma._bearings</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">Generic</span><span class="p">,</span>
    <span class="n">Pattern</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">Type</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">._exceptions</span> <span class="kn">import</span> <span class="n">NullNameError</span>


<span class="n">_NameType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;_NameType&quot;</span><span class="p">)</span>
<span class="n">FactoryType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;FactoryType&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="BearingAbstract"><a class="viewcode-back" href="../../bearings.html#gemma.BearingAbstract">[docs]</a><span class="k">class</span> <span class="nc">BearingAbstract</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">_NameType</span><span class="p">]):</span>
    <span class="n">REGEX</span><span class="p">:</span> <span class="n">Pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;.+&quot;</span><span class="p">)</span>
    <span class="n">NAME_TYPES</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">_NameType</span><span class="p">,</span> <span class="s2">&quot;BearingAbstract[_NameType]&quot;</span><span class="p">],</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span>
        <span class="n">factory</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">FactoryType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;BearingAbstract&quot;</span><span class="p">:</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">BearingAbstract</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="n">is_compatible</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;type {type(name)} not allowed as </span><span class="si">{cls}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">new_bearing</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_bearing</span>

<div class="viewcode-block" id="BearingAbstract.__init__"><a class="viewcode-back" href="../../bearings.html#gemma.BearingAbstract.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">_NameType</span><span class="p">,</span> <span class="s2">&quot;BearingAbstract[_NameType]&quot;</span><span class="p">],</span>
        <span class="n">factory</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">FactoryType</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract base class for :class:`Course` bearings.</span>

<span class="sd">        **inherits from:** ``Generic[_NameType]``</span>

<span class="sd">        :param name: name of key/index/attribute/method/etc to act on.</span>
<span class="sd">        :param factory: ``type`` to be used as default value if :func:`Course.place`</span>
<span class="sd">            hits empty or non-existent value so structure can be built</span>

<span class="sd">        Class-level Attributes</span>
<span class="sd">            - **REGEX**: ( ``re.Pattern`` ) - Regex pattern to match string shorthand</span>
<span class="sd">            - **NAME_TYPES** ( ``List[Union[Type, Any]]`` ) - ``type`` ( or ``tuple`` of</span>
<span class="sd">              types ) that ``name`` can be.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">BearingAbstract</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">:</span> <span class="n">_NameType</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_factory</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">FactoryType</span><span class="p">]]</span> <span class="o">=</span> <span class="n">factory</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">BearingAbstract</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;bearings cannot be compared to other types&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Fallback</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">BEARING_CLASSES</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Fallback</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">BEARING_CLASSES</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;BearingAbstract&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_key</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_key</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;BearingAbstract&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_key</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_key</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;BearingAbstract&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_key</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_key</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;BearingAbstract&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_key</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_key</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
            <span class="n">name_print</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name_print</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="n">name_print</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&lt;{type(self).__name__}: </span><span class="si">{name_print}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">factory_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name_print</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;, factory=</span><span class="si">{self.factory_type.__name__}</span><span class="s2">&quot;</span>
        <span class="n">name_print</span> <span class="o">+=</span> <span class="s2">&quot;&gt;&quot;</span>
        <span class="k">return</span> <span class="n">name_print</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;:returns: string value for use in Data path string&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_sort_key</span><span class="p">(</span><span class="n">bearing_obj</span><span class="p">:</span> <span class="s2">&quot;BearingAbstract&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Key that bearings are sorted by.</span>

<span class="sd">        Sorts:</span>
<span class="sd">            1. By class: Item, Attr, Call, [Custom Implementation by name], Bearing</span>
<span class="sd">            2. Bearing name type (alphabetical by class, ex: float, int, str)</span>
<span class="sd">            3. value of bearing name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">type_value</span> <span class="o">=</span> <span class="n">TYPE_SORT_ORDER</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">bearing_obj</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">type_value</span> <span class="o">=</span> <span class="n">TYPE_SORT_ORDER</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;other&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">type_value</span><span class="p">,</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">bearing_obj</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="nb">type</span><span class="p">(</span><span class="n">bearing_obj</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">bearing_obj</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;_NameType&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read-only property.</span>

<span class="sd">        :return: ``name`` passed to ``__init__``.</span>

<span class="sd">        &gt;&gt;&gt; from gemma import Attr</span>
<span class="sd">        &gt;&gt;&gt; attribute = Attr(&#39;a&#39;)</span>
<span class="sd">        &gt;&gt;&gt; attribute.name</span>
<span class="sd">        a</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">factory_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">FactoryType</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read-only property.</span>

<span class="sd">        :return: ``factory`` passed to ``__init__``.</span>

<span class="sd">        &gt;&gt;&gt; from gemma import Attr</span>
<span class="sd">        &gt;&gt;&gt; attribute = Attr(&#39;a&#39;, factory=dict)</span>
<span class="sd">        &gt;&gt;&gt; attribute.factory_type</span>
<span class="sd">        dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_factory</span>

<div class="viewcode-block" id="BearingAbstract.init_factory"><a class="viewcode-back" href="../../bearings.html#gemma.BearingAbstract.init_factory">[docs]</a>    <span class="k">def</span> <span class="nf">init_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FactoryType</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **MAY BE IMPLEMENTED**</span>

<span class="sd">        Returns an initialized version of :func:`BearingAbstract.factory`.</span>

<span class="sd">        :return: initialized data object</span>
<span class="sd">        :raises TypeError: is factory is not callable</span>

<span class="sd">        DEFAULT IMPLEMENTATION: initializes object with no parameters.</span>

<span class="sd">        &gt;&gt;&gt; from gemma import Attr</span>
<span class="sd">        &gt;&gt;&gt; attribute = Attr(&#39;a&#39;, factory=dict)</span>
<span class="sd">        &gt;&gt;&gt; attribute.init_factory()</span>
<span class="sd">        {}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">factory_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;factory type is None&quot;</span><span class="p">)</span>

        <span class="c1"># There is a mypy bug here. This typing is correct.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">factory_type</span><span class="p">()</span>  <span class="c1"># type: ignore</span></div>

<div class="viewcode-block" id="BearingAbstract.fetch"><a class="viewcode-back" href="../../bearings.html#gemma.BearingAbstract.fetch">[docs]</a>    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **MUST BE IMPLEMENTED**</span>

<span class="sd">        Fetches value from target object by :func:`BearingAbstract.name`</span>

<span class="sd">        :param target: object to fetch value from</span>
<span class="sd">        :return: value to be fetched</span>
<span class="sd">        :raises NullNameError: generic error when bearing cannot be found</span>
<span class="sd">        :raises TypeError: when ``target`` is wrong type for bearing</span>

<span class="sd">        See documentation of the default Bearing implementations for examples:</span>

<span class="sd">            - :func:`Attr.fetch`</span>
<span class="sd">            - :func:`Item.fetch`</span>
<span class="sd">            - :func:`Call.fetch`</span>
<span class="sd">            - :func:`Fallback.fetch`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="BearingAbstract.place"><a class="viewcode-back" href="../../bearings.html#gemma.BearingAbstract.place">[docs]</a>    <span class="k">def</span> <span class="nf">place</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **MUST BE IMPLEMENTED**</span>

<span class="sd">        Sets ``value`` at :func:`BearingAbstract.name` of target object.</span>

<span class="sd">        :param target: target object to set value</span>
<span class="sd">        :param value: value to set</span>
<span class="sd">        :returns None: method should not return anything</span>
<span class="sd">        :raises NullNameError: :class:`NullNameError` should be raised if bearing</span>
<span class="sd">            cannot be placed</span>
<span class="sd">        :raises TypeError: When ``target`` is wrong type for Bearing</span>

<span class="sd">        See documentation of the default Bearing implementations for examples.</span>

<span class="sd">            - :func:`Attr.place`</span>
<span class="sd">            - :func:`Item.place`</span>
<span class="sd">            - :func:`Call.place`</span>
<span class="sd">            - :func:`Fallback.place`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="BearingAbstract.name_from_str"><a class="viewcode-back" href="../../bearings.html#gemma.BearingAbstract.name_from_str">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">name_from_str</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **MAY BE IMPLEMENTED**</span>

<span class="sd">        Casts string to appropriate type for ``name`` param of ``__init__``.</span>

<span class="sd">        :param text: text to cast</span>
<span class="sd">        :return: cast value.</span>
<span class="sd">        :raises ValueError: if ``text`` is not cast-able.</span>

<span class="sd">        DEFAULT IMPLEMENTATION: Tests if the ``text`` matches to the regex pattern in</span>
<span class="sd">        ``BearingAbstract.REGEX``, then extracts name from pattern.</span>

<span class="sd">        Raises ``ValueError`` if no match.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">REGEX</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;text does not match regex&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">match</span><span class="o">.</span><span class="n">string</span></div>

<div class="viewcode-block" id="BearingAbstract.is_compatible"><a class="viewcode-back" href="../../bearings.html#gemma.BearingAbstract.is_compatible">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">is_compatible</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        **MAY BE IMPLEMENTED**</span>

<span class="sd">        Checks whether the ``name`` can be cast to current type.</span>

<span class="sd">        :param name: value to be cast</span>
<span class="sd">        :return:</span>
<span class="sd">            - ``True``: Can be cast.</span>
<span class="sd">            - ``False``: Cannot be cast</span>

<span class="sd">        DEFAULT IMPLEMENTATION: checks whether the type of ``name`` is in</span>
<span class="sd">        ``cls.NAME_TYPES``.</span>

<span class="sd">        Most Bearing implementations will not need to override this method, instead</span>
<span class="sd">        supplying a list of acceptable types to ``cls.NAME_TYPES``.</span>

<span class="sd">        However, some Bearings may depend on criteria other than type and override this</span>
<span class="sd">        method, possibly making ``cls.NAME_TYPES`` irrelevant.</span>

<span class="sd">        For example, a bearing used to fetch and set data from the ``dataclasses``</span>
<span class="sd">        module might re-implement :func:`BearingAbstract.is_compatible` as a wrapper for</span>
<span class="sd">        ``dataclasses.is_dataclass()``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">kind</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">NAME_TYPES</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="ow">is</span> <span class="n">Any</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">kind</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span></div></div>


<div class="viewcode-block" id="Attr"><a class="viewcode-back" href="../../bearings.html#gemma.Attr">[docs]</a><span class="k">class</span> <span class="nc">Attr</span><span class="p">(</span><span class="n">BearingAbstract</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
    <span class="n">REGEX</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;@(.+)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;@</span><span class="si">{self.name}</span><span class="s2">&quot;</span>

<div class="viewcode-block" id="Attr.fetch"><a class="viewcode-back" href="../../bearings.html#gemma.Attr.fetch">[docs]</a>    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fetches attribute of target.</span>

<span class="sd">        :param target: Object to fetch attribute from</span>
<span class="sd">        :return: Value of attribute</span>
<span class="sd">        :raises NullNameError: if attribute does not exist</span>

<span class="sd">        Equivalent to:</span>

<span class="sd">        &gt;&gt;&gt; getattr(target, self.name)</span>

<span class="sd">        Example:</span>

<span class="sd">        &gt;&gt;&gt; from gemma import Attr</span>
<span class="sd">        &gt;&gt;&gt; from dataclasses import dataclass</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; @dataclass</span>
<span class="sd">        ... class Data:</span>
<span class="sd">        ...     a: str = &#39;value&#39;</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; data = Data()</span>
<span class="sd">        &gt;&gt;&gt; Attr(&#39;a&#39;).fetch(data)</span>
<span class="sd">        &#39;value&#39;</span>

<span class="sd">        If target does not have an attribute of bearing.name:</span>

<span class="sd">        &gt;&gt;&gt; Attr(&#39;b&#39;).fetch(data)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        gemma._exceptions.NullNameError: @b&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NullNameError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="Attr.place"><a class="viewcode-back" href="../../bearings.html#gemma.Attr.place">[docs]</a>    <span class="k">def</span> <span class="nf">place</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets Attribute of target to ``value``.</span>

<span class="sd">        :param target: Object to set attribute on</span>
<span class="sd">        :param value: Value to set on attribute</span>
<span class="sd">        :return: None</span>
<span class="sd">        :raises NullNameError: if attribute does not exist</span>

<span class="sd">        Equivalent to:</span>

<span class="sd">        &gt;&gt;&gt; setattr(target, self.name, value)</span>

<span class="sd">        Example, using ``data`` from the fetch example above:</span>

<span class="sd">        &gt;&gt;&gt; data.a</span>
<span class="sd">        &#39;value&#39;</span>
<span class="sd">        &gt;&gt;&gt; Attr(&#39;a&#39;).place(data, &#39;changed&#39;)</span>
<span class="sd">        &gt;&gt;&gt; data.a</span>
<span class="sd">        &#39;changed&#39;</span>

<span class="sd">        If target does not have an attribute of bearing.name:</span>

<span class="sd">        &gt;&gt;&gt; Attr(&#39;b&#39;).place(data, &#39;changed again&#39;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        gemma._exceptions.NullNameError: @b</span>

<span class="sd">        Unlike ``setattr()``, :func:`Attr.place` cannot be used to declare arbitrary</span>
<span class="sd">        attributes. Non-existent attributes will raise a NullNameError.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NullNameError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;values set through Attr cannot be callable&quot;</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Item"><a class="viewcode-back" href="../../bearings.html#gemma.Item">[docs]</a><span class="k">class</span> <span class="nc">Item</span><span class="p">(</span><span class="n">BearingAbstract</span><span class="p">[</span><span class="n">Any</span><span class="p">]):</span>
    <span class="n">REGEX</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\[(.+)\]&quot;</span><span class="p">)</span>
    <span class="n">NAME_TYPES</span> <span class="o">=</span> <span class="p">[</span><span class="n">Any</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;[{str(self.name)}]&quot;</span>

<div class="viewcode-block" id="Item.fetch"><a class="viewcode-back" href="../../bearings.html#gemma.Item.fetch">[docs]</a>    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fetches data at index or key of ``target``</span>

<span class="sd">        :param target: object to fetch data from</span>
<span class="sd">        :return: value of index/key</span>
<span class="sd">        :raises NullNameError: if index/key does not exist</span>
<span class="sd">        :raises TypeError: if Target does not have a valid ``__getitem__`` method</span>

<span class="sd">        Fetch data from a list:</span>

<span class="sd">        &gt;&gt;&gt; from gemma import Item</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; data_list = [&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;]</span>
<span class="sd">        &gt;&gt;&gt; item = Item(0)</span>
<span class="sd">        &gt;&gt;&gt; item.fetch(data_list)</span>
<span class="sd">        &#39;zero&#39;</span>

<span class="sd">        Fetch data from a dict:</span>

<span class="sd">        &gt;&gt;&gt; data_dict = {&quot;a&quot;: &quot;a value&quot;, &quot;b&quot;: &quot;b value&quot;}</span>
<span class="sd">        &gt;&gt;&gt; item = Item(&quot;b&quot;)</span>
<span class="sd">        &gt;&gt;&gt; item.fetch(data_dict)</span>
<span class="sd">        &#39;b value&#39;</span>

<span class="sd">        Fetching an Index / Item that does not exist raises :class:`NullNameError`</span>

<span class="sd">        &gt;&gt;&gt; out_of_index = Item(5)</span>
<span class="sd">        &gt;&gt;&gt; out_of_index.fetch(data_list)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">        gemma._exceptions.NullNameError: [5]</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; bad_key = Item(&quot;c&quot;)</span>
<span class="sd">        &gt;&gt;&gt; bad_key.fetch(data_dict)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">        gemma._exceptions.NullNameError: [c]</span>

<span class="sd">        An invalid name raises a :class:`NullNameError` regardless of whether</span>
<span class="sd">        the ``target`` object would normally raise a ``KeyError`` or ``IndexError``.</span>

<span class="sd">        Fetching from a ``target`` which does not support ``__getitem__`` raises a</span>
<span class="sd">        ``TypeError``.</span>

<span class="sd">        &gt;&gt;&gt; no_get_item = int(1)</span>
<span class="sd">        &gt;&gt;&gt; bad_key.fetch(no_get_item)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">        TypeError: &#39;int&#39; object is not subscriptable</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">target</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">NullNameError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="Item.place"><a class="viewcode-back" href="../../bearings.html#gemma.Item.place">[docs]</a>    <span class="k">def</span> <span class="nf">place</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets ``value`` at Index/Key of ``target``</span>

<span class="sd">        :param target: object to set ``value`` on.</span>
<span class="sd">        :param value: value to set.</span>
<span class="sd">        :return: None</span>
<span class="sd">        :raises NullNameError: When Index/Key cannot be set</span>
<span class="sd">        :raises TypeError: When ``target`` does not support ``__setitem__``</span>

<span class="sd">        Changing an existing dict key:</span>

<span class="sd">        &gt;&gt;&gt; from gemma import Item</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; data_dict = {&quot;a&quot;: &quot;a value&quot;, &quot;b&quot;: &quot;b value&quot;}</span>
<span class="sd">        &gt;&gt;&gt; existing_item = Item(&quot;b&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; existing_item.place(data_dict, &quot;changed&quot;)</span>
<span class="sd">        &gt;&gt;&gt; data_dict</span>
<span class="sd">        {&#39;a&#39;: &#39;a value&#39;, &#39;b&#39;: &#39;changed&#39;}</span>

<span class="sd">        Setting a new dict key:</span>

<span class="sd">        &gt;&gt;&gt; new_item = Item(&quot;c&quot;)</span>
<span class="sd">        &gt;&gt;&gt; new_item.place(data_dict, &quot;new&quot;)</span>
<span class="sd">        &gt;&gt;&gt; data_dict</span>
<span class="sd">        {&#39;a&#39;: &#39;a value&#39;, &#39;b&#39;: &#39;changed&#39;, &#39;c&#39;: &#39;new&#39;}</span>

<span class="sd">        Changing an existing list index:</span>

<span class="sd">        &gt;&gt;&gt; data_list = [&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;]</span>
<span class="sd">        &gt;&gt;&gt; item = Item(0)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; item.place(data_list, &quot;changed&quot;)</span>
<span class="sd">        &gt;&gt;&gt; data_list</span>
<span class="sd">        [&#39;changed&#39;, &#39;one&#39;, &#39;two&#39;]</span>

<span class="sd">        Changing an index out of range does not result in :class:`NullNameError`,</span>
<span class="sd">        as it does with :func:`Item.fetch`.</span>

<span class="sd">        &gt;&gt;&gt; out_of_index = Item(5)</span>
<span class="sd">        &gt;&gt;&gt; out_of_index.place(data_list, &quot;new value&quot;)</span>
<span class="sd">        &gt;&gt;&gt; data_list</span>
<span class="sd">        [&#39;changed&#39;, &#39;one&#39;, &#39;two&#39;, None, None, &#39;new value&#39;]</span>

<span class="sd">        ``None`` is inserted in any missing indexes between the last existing index and</span>
<span class="sd">        the new index.</span>

<span class="sd">        Attempting to place a value on a ``target`` that does not support</span>
<span class="sd">        ``__setitem__`` raises a ``TypeError``:</span>

<span class="sd">        &gt;&gt;&gt; data_tuple = (&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;)</span>
<span class="sd">        &gt;&gt;&gt; cannot_set = Item(0)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; cannot_set.place(data_tuple, &quot;changed&quot;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        TypeError: &#39;tuple&#39; object does not support item assignment</span>

<span class="sd">        If the object would normally raise a ``KeyError`` or ``IndexError``, it is cast</span>
<span class="sd">        to a :class:`NullNameError`.</span>

<span class="sd">        Let us create a dict class that raises a ``KeyError`` when attempting to set any</span>
<span class="sd">        key that is not present upon initialization:</span>

<span class="sd">        &gt;&gt;&gt; class StrictDict(dict):</span>
<span class="sd">        ...     def __setitem__(self, item, value):</span>
<span class="sd">        ...         if not item in self:</span>
<span class="sd">        ...             raise KeyError</span>
<span class="sd">        ...         super().__setitem__(item, value)</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; strict = StrictDict({&quot;a&quot;: &quot;a value&quot;, &quot;b&quot;: &quot;b value&quot;})</span>
<span class="sd">        &gt;&gt;&gt; strict[&quot;c&quot;] = &quot;changed&quot;</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">        KeyError</span>

<span class="sd">        :class:`Item` &#39;s place method will cast the ``KeyError`` to a</span>
<span class="sd">        :class:`NullNameError`.</span>

<span class="sd">        &gt;&gt;&gt; raises_key = Item(&quot;c&quot;)</span>
<span class="sd">        &gt;&gt;&gt; raises_key.place(strict, &quot;changed&quot;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">        gemma._exceptions.NullNameError: [c]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">target</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NullNameError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">List</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)):</span>
                    <span class="n">target</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">target</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">return</span>
            <span class="k">raise</span> <span class="n">NullNameError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="Call"><a class="viewcode-back" href="../../bearings.html#gemma.Call">[docs]</a><span class="k">class</span> <span class="nc">Call</span><span class="p">(</span><span class="n">BearingAbstract</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
    <span class="n">REGEX</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(.+?)\(\)&quot;</span><span class="p">)</span>
    <span class="c1"># we are going to use this to see when we need to sub out args for value</span>
    <span class="n">VALUE_ARG</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

<div class="viewcode-block" id="Call.__init__"><a class="viewcode-back" href="../../bearings.html#gemma.Call.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">func_args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">func_kwargs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param name: method name to act on</span>
<span class="sd">        :param func_args: ``*args`` to pass to method when fetching or placing</span>
<span class="sd">        :param func_kwargs: ``**kwargs`` to pass to method when fetching or placing</span>

<span class="sd">        Class Attributes:</span>
<span class="sd">            - **VALUE_ARG (** ``Any`` **):** object to act as placeholder in</span>
<span class="sd">              ``func_args`` and ``func_kwargs``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">func_args</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">func_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">func_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">func_args</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">func_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">func_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_func_args</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="n">func_args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_func_kwargs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">func_kwargs</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{self.name}</span><span class="s2">()&quot;</span>

<div class="viewcode-block" id="Call.fetch"><a class="viewcode-back" href="../../bearings.html#gemma.Call.fetch">[docs]</a>    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fetches value from method of ``target``</span>

<span class="sd">        :param target: Object to call method on.</span>
<span class="sd">        :return: return of method</span>

<span class="sd">        Getting the keys of a dict:</span>

<span class="sd">        &gt;&gt;&gt; from gemma import Call</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; data_dict = {&quot;a&quot;: &quot;a value&quot;, &quot;b&quot;: &quot;b value&quot;}</span>
<span class="sd">        &gt;&gt;&gt; method = Call(&quot;keys&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; method.fetch(data_dict)</span>
<span class="sd">        dict_keys([&#39;a&#39;, &#39;b&#39;])</span>

<span class="sd">        If the method does not exist, a :class:`NullNameError` is raised.</span>

<span class="sd">        &gt;&gt;&gt; invalid_method = Call(&quot;does_not_exist&quot;)</span>
<span class="sd">        &gt;&gt;&gt; invalid_method.fetch(data_dict)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">        gemma._exceptions.NullNameError: does_not_exist()</span>

<span class="sd">        When fetching a value, call will pass the ``func_args`` and ``func_kwargs``</span>
<span class="sd">        passed to ``__init__`` as ``*args`` and ``*kwargs``</span>

<span class="sd">        &gt;&gt;&gt; data_list = [&quot;repeat&quot;, &quot;one&quot;, &quot;two&quot;, &quot;repeat&quot;]</span>
<span class="sd">        &gt;&gt;&gt; method = Call(&quot;index&quot;, func_args=(&quot;repeat&quot;, 1))</span>
<span class="sd">        &gt;&gt;&gt; method.fetch(data_list)</span>
<span class="sd">        3</span>

<span class="sd">        This is equivalent to</span>

<span class="sd">        &gt;&gt;&gt; data_list.index(&quot;repeat&quot;, 1)</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NullNameError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_func_args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_func_kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_replace_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replaces CALL.VALUE in self._func_args and kwargs with ``value``.</span>

<span class="sd">        :param value:</span>
<span class="sd">        :return: (*args, *kwargs)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value_replaced</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func_kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="n">Call</span><span class="o">.</span><span class="n">VALUE_ARG</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="n">value_replaced</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func_args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Call</span><span class="o">.</span><span class="n">VALUE_ARG</span><span class="p">:</span>
                <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">value_replaced</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">value_replaced</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span>

<div class="viewcode-block" id="Call.place"><a class="viewcode-back" href="../../bearings.html#gemma.Call.place">[docs]</a>    <span class="k">def</span> <span class="nf">place</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Places value with method of ``target``.</span>

<span class="sd">        :param target: Object to call method on</span>
<span class="sd">        :param value: value to pass</span>
<span class="sd">        :return: None</span>

<span class="sd">        By default, ``value`` is passed as the first argument to the given method.</span>

<span class="sd">        Appending value at end of list:</span>

<span class="sd">        &gt;&gt;&gt; from gemma import Call</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; data_list = [&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;]</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; adds_value = Call(&quot;append&quot;)</span>
<span class="sd">        &gt;&gt;&gt; adds_value.place(data_list, &quot;three&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; data_list</span>
<span class="sd">        [&#39;zero&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;]</span>

<span class="sd">        Any additional args are passed as positional arguments, *after* ``value``. Let</span>
<span class="sd">        us create a list class with a method that will attempt to cast a value to a</span>
<span class="sd">        given type before appending it to the list:</span>

<span class="sd">        &gt;&gt;&gt; class MultiArg(list):</span>
<span class="sd">        ...     def cast_append(self, value, cast_type=None):</span>
<span class="sd">        ...         try:</span>
<span class="sd">        ...             value = cast_type(value)</span>
<span class="sd">        ...         except (TypeError, ValueError):</span>
<span class="sd">        ...             pass</span>
<span class="sd">        ...         self.append(value)</span>
<span class="sd">        ...</span>
<span class="sd">        ...     def args_reversed(self, cast_type=None, value=None):</span>
<span class="sd">        ...         self.cast_append(value, cast_type)</span>
<span class="sd">        ...</span>

<span class="sd">        We can pass ``str`` to the ``cast_type`` parameter by setting it as the first</span>
<span class="sd">        additional argument to :class:`Call`.</span>

<span class="sd">        &gt;&gt;&gt; data_list = MultiArg((&#39;zero&#39;, &#39;one&#39;, &#39;two&#39;))</span>
<span class="sd">        &gt;&gt;&gt; data_list</span>
<span class="sd">        [&#39;zero&#39;, &#39;one&#39;, &#39;two&#39;]</span>
<span class="sd">        &gt;&gt;&gt; casts_str = Call(&#39;cast_append&#39;, func_args=(str,))</span>
<span class="sd">        &gt;&gt;&gt; casts_str.place(data_list, 3)</span>
<span class="sd">        &gt;&gt;&gt; data_list</span>
<span class="sd">        [&#39;zero&#39;, &#39;one&#39;, &#39;two&#39;, &#39;3&#39;]</span>

<span class="sd">        This is equivalent to:</span>

<span class="sd">        &gt;&gt;&gt; data_list.cast_append(3, str)</span>

<span class="sd">        We can also pass ``cast_type`` as a keyword argument.</span>

<span class="sd">        &gt;&gt;&gt; casts_str = Call(&#39;cast_append&#39;, func_kwargs={&#39;cast_type&#39;: str})</span>
<span class="sd">        &gt;&gt;&gt; casts_str.place(data_list, 4)</span>
<span class="sd">        &gt;&gt;&gt; data_list</span>
<span class="sd">        [&#39;zero&#39;, &#39;one&#39;, &#39;two&#39;, &#39;3&#39;, &#39;4&#39;]</span>

<span class="sd">        For most setter methods, it is likely that the value will be the first argument</span>
<span class="sd">        passed. However, this is not always the case. Take ``list.insert()`` -- the</span>
<span class="sd">        first argument is the index where the value is inserted.</span>

<span class="sd">        &gt;&gt;&gt; data_list = [&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;]</span>
<span class="sd">        &gt;&gt;&gt; data_list.insert(0, &quot;new&quot;)</span>
<span class="sd">        &gt;&gt;&gt; data_list</span>
<span class="sd">        [&#39;new&#39;, &#39;zero&#39;, &#39;one&#39;, &#39;two&#39;]</span>

<span class="sd">        In this case, if we want a bearing that places ``value`` at the head of a</span>
<span class="sd">        ``list``, we need to pass ``value`` as the *second* argument.</span>

<span class="sd">        We can use the ``Call.VALUE_ARG`` object to indicate that instead of being</span>
<span class="sd">        placed as the first argument, ``value`` should replace the ``Call.VALUE_ARG``</span>
<span class="sd">        whenever a new value is passed to the bearing.</span>

<span class="sd">        &gt;&gt;&gt; data_list = [&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;]</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; inserts_head = Call(&quot;insert&quot;, func_args=(0, Call.VALUE_ARG))</span>
<span class="sd">        &gt;&gt;&gt; inserts_head.place(data_list, &quot;new&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; data_list</span>
<span class="sd">        [&#39;new&#39;, &#39;zero&#39;, &#39;one&#39;, &#39;two&#39;]</span>

<span class="sd">        This also works with ``**kwarg values``. Using the ``MultiArg``, class from</span>
<span class="sd">        above:</span>

<span class="sd">        &gt;&gt;&gt; data_list = MultiArg((&#39;zero&#39;, &#39;one&#39;, &#39;two&#39;))</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; kwargs = {&#39;value&#39;: Call.VALUE_ARG, &#39;cast_type&#39;: str}</span>
<span class="sd">        &gt;&gt;&gt; inserts_head = Call(&quot;args_reversed&quot;, func_kwargs=kwargs)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; inserts_head.place(data_list, 3)</span>
<span class="sd">        &gt;&gt;&gt; inserts_head</span>
<span class="sd">        [&#39;zero&#39;, &#39;one&#39;, &#39;two&#39;, &#39;3&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NullNameError</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_args</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="n">method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<span class="n">_BEARING_CLASSES</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">BearingAbstract</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Item</span><span class="p">,</span> <span class="n">Call</span><span class="p">,</span> <span class="n">Attr</span><span class="p">]</span>


<div class="viewcode-block" id="Fallback"><a class="viewcode-back" href="../../bearings.html#gemma.Fallback">[docs]</a><span class="k">class</span> <span class="nc">Fallback</span><span class="p">(</span><span class="n">BearingAbstract</span><span class="p">[</span><span class="n">Any</span><span class="p">]):</span>
    <span class="n">NAME_TYPES</span> <span class="o">=</span> <span class="p">[</span><span class="n">Any</span><span class="p">]</span>
    <span class="n">BEARING_CLASSES</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">BearingAbstract</span><span class="p">]]</span> <span class="o">=</span> <span class="n">_BEARING_CLASSES</span>

<div class="viewcode-block" id="Fallback.__init__"><a class="viewcode-back" href="../../bearings.html#gemma.Fallback.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempts to fetch or place data on a target using other bearing class&#39; methods.</span>

<span class="sd">        :param name: name of bearing.</span>

<span class="sd">        **inherits from:** :class:`BearingAbstract`</span>

<span class="sd">        **name types:** ``Any``.</span>

<span class="sd">        **shorthand:** ``&quot;name&quot;``</span>

<span class="sd">        Class Attributes:</span>
<span class="sd">            - **BEARING_CLASSES (** ``List[Type[BearingAbstract]]`` **):** bearing</span>
<span class="sd">              classes to cycle through when attempting to fetch or place data.</span>

<span class="sd">        The available methods and order of attempts is determined by the list of types</span>
<span class="sd">        in ``Fallback.BEARING_CLASSES``. This makes bearing less performant than</span>
<span class="sd">        invoking one of its test classes directly, but does make setting up</span>
<span class="sd">        :class:`Course` objects easier and less tedious. The performance hit may or may</span>
<span class="sd">        not be worth it depending on your workflow.</span>

<span class="sd">        The default ``BEARING_CLASSES`` are :class:`Item`, :class:`Call`,</span>
<span class="sd">        and :class:`Attr`, though that can be extended by inheriting this class</span>

<span class="sd">        Meant as a generic class when the bearing type is not well defined in a string</span>
<span class="sd">        ( Allows for more compact, generic :class:`Course` declarations ).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<div class="viewcode-block" id="Fallback.fetch"><a class="viewcode-back" href="../../bearings.html#gemma.Fallback.fetch">[docs]</a>    <span class="k">def</span> <span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempts to fetch data from ``target`` object.</span>

<span class="sd">        :param target: object to fetch data from.</span>
<span class="sd">        :return: value</span>

<span class="sd">        Cycles through the classes in ``Fallback.BEARING_CLASSES``, casting the current</span>
<span class="sd">        Bearing to each type, and invoking their ``fetch()`` method.</span>

<span class="sd">        If the cast or fetch results in a :class:``NullNameError``, ``TypeError``, or</span>
<span class="sd">        ``ValueError``, the exception is caught and the next class is tried.</span>

<span class="sd">        By default, :class:`Fallback` cycles through ``fetch()`` on :class:`Item`,</span>
<span class="sd">        :class:`Attr`, and :class:`Call`, in that order.</span>

<span class="sd">        With the default classes, if an attribute exists, it will be fetched.</span>

<span class="sd">        &gt;&gt;&gt; from gemma import Fallback</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; class TestData:</span>
<span class="sd">        ...     pass</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; test_data = TestData()</span>
<span class="sd">        &gt;&gt;&gt; test_data.a = &#39;a value&#39;</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; to_fetch = Fallback(&#39;a&#39;)</span>
<span class="sd">        &gt;&gt;&gt; to_fetch.fetch(test_data)</span>
<span class="sd">        &#39;a value&#39;</span>

<span class="sd">        Same with an Index.</span>

<span class="sd">        &gt;&gt;&gt; data_dict = {&quot;a&quot;: &quot;a dict&quot;}</span>
<span class="sd">        &gt;&gt;&gt; to_fetch.fetch(data_dict)</span>
<span class="sd">        &#39;a dict&#39;</span>

<span class="sd">        Same with a method.</span>

<span class="sd">        &gt;&gt;&gt; class FetchMethod:</span>
<span class="sd">        ...     def a(self):</span>
<span class="sd">        ...         return &#39;a method&#39;</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; test_data = FetchMethod()</span>
<span class="sd">        &gt;&gt;&gt; to_fetch.fetch(test_data)</span>
<span class="sd">        &#39;a method&#39;</span>

<span class="sd">        When an name has multiple compatible bearings, it takes the first method&#39;s value</span>
<span class="sd">        that does not throw an exception.</span>

<span class="sd">        &gt;&gt;&gt; class TwoValid(dict):</span>
<span class="sd">        ...     def a(self):</span>
<span class="sd">        ...         return &#39;a method&#39;</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; data_dict = TwoValid({&#39;a&#39;: &#39;a item&#39;})</span>
<span class="sd">        &gt;&gt;&gt; to_fetch.fetch(data_dict)</span>
<span class="sd">        &#39;a item&#39;</span>

<span class="sd">        Both ``Item(&#39;a&#39;)`` and ``Call(&#39;a&#39;)`` would return valid values --</span>
<span class="sd">        ``&quot;a method&quot;`` and ``&quot;a item&quot;``, respectively -- but since :class:`Item` is</span>
<span class="sd">        tried first and gets a valid response, the key value is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">bearing_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">BEARING_CLASSES</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">cast_bearing</span> <span class="o">=</span> <span class="n">bearing_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cast_bearing</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="n">NullNameError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">pass</span>

        <span class="k">raise</span> <span class="n">NullNameError</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="Fallback.place"><a class="viewcode-back" href="../../bearings.html#gemma.Fallback.place">[docs]</a>    <span class="k">def</span> <span class="nf">place</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempts to set ``value`` on ``target``.</span>

<span class="sd">        :param target: Object to set ``value`` on.</span>
<span class="sd">        :param value: Value to set.</span>
<span class="sd">        :return: None</span>

<span class="sd">        Attempts to place data on a given name of ``target`` by cycling through the</span>
<span class="sd">        classes in ``Fallback.BEARING_CLASSES``, casting the current Bearing to each</span>
<span class="sd">        type, and invoking their ``place()`` method.</span>

<span class="sd">        If the cast or place results in a :class:`NullNameError`, ``TypeError``, or</span>
<span class="sd">        ``ValueError``, the exception is caught and the next class is tried.</span>

<span class="sd">        By default, :class:`Fallback` cycles through ``place()`` on :class:`Item`,</span>
<span class="sd">        :class:`Attr`, and :class:`Call`, in that order.</span>

<span class="sd">        With the default classes, if an attribute exists, it will be placed.</span>

<span class="sd">        &gt;&gt;&gt; from gemma import Fallback</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; class TestData:</span>
<span class="sd">        ...     a = None</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; test_data = TestData()</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; to_place = Fallback(&quot;a&quot;)</span>
<span class="sd">        &gt;&gt;&gt; to_place.place(test_data, &quot;a attr&quot;)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; test_data.a</span>
<span class="sd">        &#39;a attr&#39;</span>

<span class="sd">        Same with an Index.</span>

<span class="sd">        &gt;&gt;&gt; data_dict = dict()</span>
<span class="sd">        &gt;&gt;&gt; to_place.place(data_dict, &quot;a dict&quot;)</span>
<span class="sd">        &gt;&gt;&gt; data_dict</span>
<span class="sd">        {&#39;a&#39;: &#39;a dict&#39;}</span>

<span class="sd">        Same with a method.</span>

<span class="sd">        &gt;&gt;&gt; class FetchMethod:</span>
<span class="sd">        ...     def a(self, value):</span>
<span class="sd">        ...         self.a = value</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; test_data = FetchMethod()</span>
<span class="sd">        &gt;&gt;&gt; to_place.place(test_data, &quot;a method&quot;)</span>
<span class="sd">        &gt;&gt;&gt; test_data.a</span>
<span class="sd">        &#39;a method&#39;</span>

<span class="sd">        When an name has multiple compatible bearings, it takes the first method&#39;s value</span>
<span class="sd">        that does not throw an exception.</span>

<span class="sd">        &gt;&gt;&gt; class TwoValid(dict):</span>
<span class="sd">        ...     def a(self, value):</span>
<span class="sd">        ...         self.a = value</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; data_dict = TwoValid()</span>
<span class="sd">        &gt;&gt;&gt; to_place.place(data_dict, &#39;a value&#39;)</span>
<span class="sd">        &gt;&gt;&gt; data_dict</span>
<span class="sd">        {&#39;a&#39;: &#39;a value&#39;}</span>
<span class="sd">        &gt;&gt;&gt; data_dict.a</span>
<span class="sd">        &lt;Item: &#39;a&#39;&gt;</span>

<span class="sd">        Both ``Item(&#39;a&#39;)`` and ``Call(&#39;a&#39;)`` would set valid values -- (to a key and</span>
<span class="sd">        attribute respectively) -- but since :class:`Item` is tried first and does not</span>
<span class="sd">        return an error, it is set to the dict&#39;s key rather than overriding</span>
<span class="sd">        it&#39;s ``a`` method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">bearing_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">BEARING_CLASSES</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">cast_bearing</span> <span class="o">=</span> <span class="n">bearing_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">cast_bearing</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="n">NullNameError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="k">raise</span> <span class="n">NullNameError</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div></div>


<span class="k">def</span> <span class="nf">_order_bearing_classes</span><span class="p">(</span>
    <span class="n">bearing_classes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">BearingAbstract</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">bearing_classes_extra</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">BearingAbstract</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">BearingAbstract</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;combines bearing_classes and bearing_classes_extra&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">bearing_classes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bearing_classes</span> <span class="o">=</span> <span class="n">_BEARING_CLASSES</span> <span class="o">+</span> <span class="p">[</span><span class="n">Fallback</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">bearing_classes_extra</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bearing_classes_extra</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">bearing_classes</span> <span class="o">=</span> <span class="n">bearing_classes_extra</span> <span class="o">+</span> <span class="n">bearing_classes</span>

    <span class="k">return</span> <span class="n">bearing_classes</span>


<span class="k">def</span> <span class="nf">attempt_name_to_bearing</span><span class="p">(</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">bearing_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">BearingAbstract</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BearingAbstract</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">bearing_type</span><span class="o">.</span><span class="n">name_from_str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">bearing_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">bearing_type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new</span>


<div class="viewcode-block" id="bearing"><a class="viewcode-back" href="../../bearings.html#gemma.bearing">[docs]</a><span class="k">def</span> <span class="nf">bearing</span><span class="p">(</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">bearing_classes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">BearingAbstract</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">bearing_classes_extra</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">BearingAbstract</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BearingAbstract</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Factory function for bearing classes.</span>

<span class="sd">    :param name: value for Bearing.name</span>
<span class="sd">    :param bearing_classes: list and order of bearing classes to attempt casting</span>
<span class="sd">    :param bearing_classes_extra: additional classes to add to bearing classes. Used</span>
<span class="sd">        to add to defaults when ``bearing_classes`` is set to ``None``.</span>
<span class="sd">    :return: Bearing object</span>

<span class="sd">    If ``name`` is a string, bearing will attempt to cast using each class&#39;</span>
<span class="sd">    :func:`BearingAbstract.from_string` method.</span>

<span class="sd">    Otherwise, bearing attempts to cast to each class normally, passing ``name`` as a</span>
<span class="sd">    single argument to each ``__init__`` method.</span>

<span class="sd">    The default list of classes to attempt are: :class:`Item`, :class:`Call`,</span>
<span class="sd">    :class:`Attr`, and :class:`Fallback` -- in that order.</span>

<span class="sd">    Any bearing types passed to ``bearing_classes_extra`` are put *ahead* of the</span>
<span class="sd">    bearings in ``bearing_classes``.</span>

<span class="sd">    Casting formatted strings:</span>

<span class="sd">    &gt;&gt;&gt; from gemma import bearing</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; bearing(&quot;[item_name]&quot;)</span>
<span class="sd">    &lt;Item: &#39;item_name&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; bearing(&quot;@attr_name&quot;)</span>
<span class="sd">    &lt;Attr: &#39;attr_name&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; bearing(&quot;call_name()&quot;)</span>
<span class="sd">    &lt;Call: &#39;call_name&#39;&gt;</span>

<span class="sd">    Passing a string which does not match any of the above class&#39; string conventions</span>
<span class="sd">    will result in a generic :class:`Fallback`.</span>

<span class="sd">    &gt;&gt;&gt; bearing(&quot;unknown_name&quot;)</span>
<span class="sd">    &lt;Fallback: &#39;unknown_name&#39;&gt;</span>

<span class="sd">    This Fallback class will be loaded with the methods of the other classes, if</span>
<span class="sd">    ``bearing_classes`` includes custom Bearings, those class&#39; methods will be added</span>
<span class="sd">    to the list. No need to make a custom subclass to extend the pool methods available</span>
<span class="sd">    to :class:`Fallback` when using this factory.</span>

<span class="sd">    Passing a non-string will always result in an :class:`Item` object with the</span>
<span class="sd">    default list, since :class:`Item` accepts all types, and is attempted first.</span>

<span class="sd">    &gt;&gt;&gt; bearing(5)</span>
<span class="sd">    &lt;Item: 5&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; bearing((5, 4))</span>
<span class="sd">    &lt;Item: (5, 4)&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">classes_loaded</span> <span class="o">=</span> <span class="n">_order_bearing_classes</span><span class="p">(</span><span class="n">bearing_classes</span><span class="p">,</span> <span class="n">bearing_classes_extra</span><span class="p">)</span>

    <span class="n">new</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">this_type</span> <span class="ow">in</span> <span class="n">classes_loaded</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">attempt_name_to_bearing</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">this_type</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">new</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span>

    <span class="c1"># load fallback class with class types.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">Fallback</span><span class="p">):</span>
        <span class="n">classes_loaded</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">classes_loaded</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Fallback</span><span class="p">)]</span>
        <span class="n">new</span><span class="o">.</span><span class="n">BEARING_CLASSES</span> <span class="o">=</span> <span class="n">classes_loaded</span>

    <span class="k">return</span> <span class="n">new</span></div>


<span class="n">TYPE_SORT_ORDER</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">BearingAbstract</span><span class="p">],</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">Item</span><span class="p">,</span>
    <span class="n">Attr</span><span class="p">,</span>
    <span class="n">Call</span><span class="p">,</span>
    <span class="s2">&quot;other&quot;</span><span class="p">,</span>
    <span class="n">Fallback</span><span class="p">,</span>
<span class="p">]</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright &#39;2018, Illuscio&#39;

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>